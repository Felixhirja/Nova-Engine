Nova-Engine Development Roadmap - Next Steps
==========================================

*** STAR CITIZEN-STYLE SPACESHIP GAME PROJECT ***
===============================================

PHASE 1: FOUNDATION (Next 1-2 months)
-------------------------------------
‚úÖ Game Design Document [COMPLETE - Living Document]
  ‚úÖ Core mechanics documented (GAME_DESIGN_DOCUMENT.md)
  ‚úÖ Solar system concept outlined
  ‚úÖ Spaceship types and classes defined
  ‚úÖ Progression systems planned
  ‚úÖ Technical specifications complete
  ‚úÖ Development phases mapped
  
  PERIODIC REFINEMENTS (Optional):
  ‚ñ° Enhance solar system details (align with implementation - see docs/solar_system_generation.md)
  ‚ñ° Add detailed component specifications as systems are built
  ‚ñ° Expand faction system with 5+ specific factions
  ‚ñ° Define resource and crafting system details
  
  See docs/game_design_assessment.md for enhancement roadmap
  Overall Completeness: 94% - Excellent foundation for Phase 1 development

‚úÖ Spaceship Classes & Components [75% COMPLETE - Core Systems Functional]
  ‚úÖ Design & taxonomy complete (docs/spaceship_taxonomy.md) - Professional quality
  ‚úÖ Core data structures implemented (src/Spaceship.h)
  ‚úÖ Ship assembly system working (src/ShipAssembly.h/cpp) - 95% complete
  ‚úÖ Gameplay systems functional (targeting, weapons, shields, energy)
  ‚úÖ Feedback systems complete (visual/audio frameworks)
  ‚úÖ Art pipeline established (docs/ship_art_pipeline.md)
  ‚úÖ Testing infrastructure in place (tests/test_ship_assembly.cpp)
  
  HIGH PRIORITY REMAINING:
  ‚úÖ Text rendering system (COMPLETE + INTEGRATED ‚úÖ)
     - ‚úÖ src/TextRenderer.h/cpp created with full API (390 lines)
     - ‚úÖ Multiple font sizes, colors, alignment, shadows, word wrapping
     - ‚úÖ Printf-style formatting with va_args
     - ‚úÖ Test suite complete: tests/test_text_rendering.cpp (all tests passing)
     - ‚úÖ Documentation: docs/text_rendering_integration.md (500+ lines)
     - ‚úÖ INTEGRATED into Viewport3D::DrawHUD() with enhanced ship stats
     - ‚úÖ Build successful, ready for runtime testing
     - See: docs/text_rendering_viewport_integration.md for integration details
  ‚ñ° Component validation with user-friendly error messages (use TextRenderer)
  ‚ñ° Advanced performance model (heat buildup, power overload)
  ‚ñ° Physics integration (coordinate with Advanced Physics Engine)
  ‚ñ° Damage model implementation (per-component health, cascading failures)
  ‚ñ° Weapon firing pipeline completion
    - Flesh out `WeaponSystem::FireWeapon` to spawn projectile entities tied to hardpoints
    - Attach muzzle flash, recoil, and heat events to Feedback systems when firing
    - Query transform/weapon mount data for accurate spawn positions + 3D audio emitters
    - Persist projectile ownership for damage attribution and AI threat evaluation
  ‚ñ° Target acquisition safeguards
    - Finish `TargetingSystem` validation (entity existence, transform availability, range/LOS)
    - Add graceful failure paths that surface issues through the feedback HUD
    - Write regression tests that cover invalid/edge targeting cases

  MEDIUM PRIORITY:
  ‚ñ° Cargo management system (for freighters)
  ‚ñ° Crew management system (station assignments, skills)
  ‚ñ° Ship progression/unlock system (research trees, reputation gates)
  ‚ñ° Cockpit/bridge UI (requires text rendering first)
  ‚ñ° Flight assist controls (auto-level, dampening, modes)
  
  See todo_spaceship.txt for complete detailed task list
  See docs/spaceship_implementation_status.md for comprehensive assessment
  Current Status: Strong foundation complete - 100-150 hours to full feature completion
  Estimated: ~4-6 weeks for Phase 1 completion

‚ñ° Advanced Physics Engine
  - Implement realistic spaceship physics (thrust, momentum, inertia, atmospheric flight)

‚è≥ Solar System Generation [IN PROGRESS]
  ‚úÖ Design document created (docs/solar_system_generation.md)
  ‚úÖ Component structures defined (src/CelestialBody.h)
  ‚úÖ Core headers created (SolarSystem.h, SolarSystemGenerator.h)
  ‚úÖ Task breakdown with time estimates (docs/solar_system_tasks.md)
  ‚úÖ Quick reference guide (docs/solar_system_quickref.md)
  
  NEXT STEPS:
  ‚ñ° Implement SolarSystem.cpp (Phase 1, Task 1.3)
  ‚ñ° Implement basic circular orbits (Phase 1, Task 1.4)
  ‚ñ° Create basic visualization with colored spheres (Phase 1, Task 1.5)
  ‚ñ° Implement SolarSystemGenerator.cpp star generation (Phase 2, Task 2.1)
  ‚ñ° Complete procedural planet generation (Phase 2, Tasks 2.3-2.7)
  
  See docs/solar_system_tasks.md for complete roadmap (275-377 hours estimated)
  Current Phase: Phase 1 - Core Framework (22-32 hours)

PHASE 2: CORE GAMEPLAY (3-6 months)
-----------------------------------
‚ñ° Ship Building & Customization
  - Create modular spaceship building system with parts, weapons, and customization

‚ñ° Combat System
  - Implement space combat mechanics (targeting, weapons, damage systems, shields)

‚ñ° Planetary Landing & Exploration
  - Create landing and exploration mechanics for planets and space stations

‚ñ° Economy & Trading
  - Build trading and economy system with markets, commodities, and player-driven economy

PHASE 3: MULTIPLAYER & WORLD (6-12 months)
------------------------------------------
‚ñ° Multiplayer Framework
  - Implement multiplayer networking for player interactions and persistent universe

‚ñ° Faction & Mission System
  - Create faction system with missions, reputation, and territorial control

‚ñ° Advanced Graphics & Effects
  - Implement shader system for advanced visual effects
  - Add particle systems for engines, explosions, and space phenomena
  - Create dynamic lighting and shadows for space environments

‚ñ° AI & NPC Systems
  - Implement AI for NPCs, pirates, and automated systems
  - Create procedural mission generation
  - Add dynamic events and encounters

*** CRITICAL ENGINE FIXES (2025-10-10) ***
==========================================

IMMEDIATE FIXES REQUIRED (High Priority):
-----------------------------------------
‚ñ° Fix GLFW initialization crash
  - glfwInit() fails immediately on current system
  - **LIKELY CAUSE: Requesting legacy OpenGL 2.1 on modern GPU**
  - Modern drivers may have poor support for old OpenGL versions
  - Try requesting OpenGL 4.3+ instead (see OpenGL 4.x upgrade)
  - Investigate GPU driver compatibility (update drivers?)
  - Try older GLFW version (3.3.x instead of 3.4)
  - Alternative: Implement native Windows OpenGL context creation
  - Test on different hardware to isolate issue
  - Consider GLEW + manual context creation as fallback
  - Document required GPU/driver versions

‚ñ° Fix XInput preloading crash
  - LoadLibraryW(L"XInput1_4.dll") causes immediate crash
  - Add better error handling with try-catch or SEH
  - Investigate delay-loading XInput
  - Test with different XInput versions (1_3, 9_1_0)
  - Make gamepad support optional and graceful
  - Add runtime detection of XInput availability

‚ñ° Fix build system clean target
  - Makefile uses Unix 'rm' which fails on Windows
  - Add PowerShell-compatible clean commands
  - Use cross-platform approach: del for Windows, rm for Unix
  - Test clean target works properly

‚ñ° Fix shell command errors in output
  - "The system cannot find the path specified" appears during run
  - "'true' is not recognized" error in console
  - Investigate source of these spurious commands
  - Clean up build/run scripts

‚úÖ SDL Dependencies [COMPLETED 2025-10-10]
  ‚úÖ Removed SDL2 and SDL_mixer from build
  ‚úÖ Deleted SDL DLLs (SDL2.dll, SDL2_mixer.dll)
  ‚úÖ Audio system now compiles without SDL_mixer (graceful fallback)
  ‚úÖ Makefile SDL detection removed

‚úÖ Headless Mode Implementation [COMPLETED 2025-10-10]
  ‚úÖ Environment variable: NOVA_ENGINE_HEADLESS="1"
  ‚úÖ Bypasses GLFW/OpenGL initialization
  ‚úÖ Frame limiter: NOVA_ENGINE_MAX_FRAMES (default: 300)
  ‚úÖ All game logic runs correctly without graphics
  ‚úÖ Input system handles null window gracefully
  ‚úÖ Viewport3D::Render() skips rendering in headless mode
  ‚úÖ Clean shutdown after frame limit reached
  ‚úÖ Documented in docs/todo/TODO_IMPROVEMENTS.md

‚úÖ Camera Direction Fix [COMPLETED 2025-10-10]
  ‚úÖ Changed initial yaw from 0.0 to œÄ/2 (1.5708 radians)
  ‚úÖ Camera now looks toward player at origin
  ‚úÖ Position: (-8, 0, 6) looking in +X direction
  ‚úÖ Pitch: -0.1 (slight downward angle)
  ‚úÖ Zoom: 12.0

DEPENDENCY & DLL MANAGEMENT:
----------------------------
‚ñ° Create DLL checker script
  - PowerShell script to verify all required DLLs present
  - Auto-copy missing DLLs from MSYS2 to project directory
  - Run before every build/execution
  
  Required DLLs:
  - glfw3.dll (graphics)
  - libfreeglut.dll (OpenGL utility)
  - libgcc_s_seh-1.dll (MinGW runtime)
  - libstdc++-6.dll (C++ standard library)
  - libwinpthread-1.dll (threading)
  - xinput1_4.dll (gamepad, optional)

‚ñ° Document all dependencies clearly
  - Create DEPENDENCIES.md with versions
  - List MSYS2 packages needed
  - Add troubleshooting section for common issues
  - Include alternative download sources

‚ñ° Consider vcpkg or Conan
  - Investigate package managers for C++ dependencies
  - Could simplify GLFW, OpenGL, audio library management
  - Test cross-platform compatibility

CAMERA SYSTEM IMPROVEMENTS:
---------------------------
‚ñ° Test camera with new direction
  - Verify all camera presets work with œÄ/2 yaw
  - Test free camera mode with mouse look
  - Test target lock mode with corrected angles
  - Verify camera-to-world coordinate transforms

‚ñ° Add camera debug visualization
  - Draw camera frustum in world space
  - Show look-at target as colored marker
  - Display camera vectors (forward, right, up)
  - Add coordinate system at camera position

‚ñ° Camera smoothing improvements
  - Tune interpolation parameters for smooth follow
  - Add acceleration/deceleration curves
  - Prevent camera jitter at low speeds
  - Add lag compensation for high-speed movement

‚ñ° Camera collision detection
  - Prevent camera from clipping through objects
  - Push camera forward when obstructed
  - Add subtle camera shake when obstructed
  - Smooth transitions when collision state changes

HEADLESS MODE ENHANCEMENTS:
--------------------------
‚ñ° Improve headless testing capabilities
  - Add scripted input injection for automated tests
  - Create input replay system from recorded sessions
  - Add visual state dumps (JSON snapshots)
  - Generate timeline logs of entity states

‚ñ° Headless performance profiling
  - Add detailed frame timing breakdown
  - Profile each game system separately
  - Generate performance reports
  - Compare headless vs graphics mode overhead

‚ñ° Headless rendering alternatives
  - Implement ASCII art improvements (better graphics)
  - Add HTML/SVG output for debugging
  - Create sprite-based 2D terminal rendering
  - Generate animated GIFs of simulation

‚ñ° Automated test suite using headless mode
  - Unit tests for all game systems
  - Integration tests for multi-system interactions
  - Regression tests for bug fixes
  - Performance benchmarks over time

INPUT SYSTEM OVERHAUL:
---------------------
‚ñ° Graceful input handling without GLFW
  - Abstract input layer from GLFW specifics
  - Support multiple input backends
  - Fallback to raw Windows input if GLFW fails
  - Test keyboard/mouse without window

‚ñ° Scripted input for testing
  - Load input sequences from files
  - Replay recorded gameplay for debugging
  - Generate random input for stress testing
  - Create AI-driven input for automated gameplay

‚ñ° Gamepad support without crashes
  - Fix XInput loading issues first
  - Add support for DirectInput
  - Support SDL_GameController as alternative
  - Map gamepad controls to game actions

‚ñ° Input configuration system
  - Save/load key bindings from file
  - In-game key rebinding UI
  - Support multiple control schemes
  - Add input sensitivity settings

GRAPHICS SYSTEM ALTERNATIVES:
-----------------------------
‚ñ° Upgrade to OpenGL 4.6 (Latest Stable - HIGH PRIORITY)
  - **Current: Legacy OpenGL 2.1 (2006) - 19 years old!**
  - **Target: OpenGL 4.6 (2017) - Latest stable version**
  - **Critical Issue: Modern GPUs may poorly support legacy OpenGL 2.1**
  - This upgrade may FIX the current GLFW initialization crashes!
  
  WHY OpenGL 4.6:
  ‚úì Best driver support on modern GPUs (NVIDIA, AMD, Intel)
  ‚úì All modern features included (compute, tessellation, geometry shaders)
  ‚úì SPIR-V shader support (portable shaders)
  ‚úì Bindless textures and buffers for massive performance
  ‚úì Multi-draw indirect with count
  ‚úì Anisotropic filtering standardized
  ‚úì Better debugging with KHR_debug
  ‚úì Lower CPU overhead, better multithreading
  ‚úì Will work on all GPUs from 2017+ (7+ years of hardware)
  
  CURRENT CODE ISSUES (src/Viewport3D.cpp:497-499):
  ```cpp
  // PROBLEM: Requesting ancient OpenGL 2.1
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
  // Missing: Core profile, forward compatibility
  ```
  
  MIGRATION PLAN:
  ‚ñ° Phase 1: Immediate Fix - Request Modern OpenGL
    - Change Viewport3D.cpp to request OpenGL 4.6 core profile
    - **This may immediately fix GLFW crash!**
    - Add fallback chain: 4.6 ‚Üí 4.5 ‚Üí 4.3 ‚Üí 3.3 ‚Üí 2.1
    - Query actual OpenGL version after context creation
    - Log GPU info: vendor, renderer, version, extensions
    - Create graphics_capabilities.log on startup
    
    Code changes needed:
    ```cpp
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
    ```
  
  ‚ñ° Phase 2: Add GLAD for Modern OpenGL Function Loading
    - Download GLAD from https://glad.dav1d.de/
    - Configuration: OpenGL 4.6, Core profile
    - Include glad/glad.h before any OpenGL headers
    - Call gladLoadGLLoader() after context creation
    - Replace current OpenGL headers with GLAD
    - Required for OpenGL 3.2+ on Windows
  
  ‚ñ° Phase 3: Remove Legacy Immediate Mode Rendering
    - Find all glBegin/glEnd calls (deprecated in 3.0+)
    - Replace with modern VAO/VBO rendering
    - Remove glVertex, glColor, glTexCoord calls
    - Use glDrawArrays/glDrawElements instead
    - Estimate: ~500 lines of code to update
  
  ‚ñ° Phase 4: Implement Modern Rendering Pipeline
    - Create Mesh class with VAO/VBO/EBO
    - Vertex Buffer Objects for all geometry data
    - Vertex Array Objects for vertex format state
    - Element Buffer Objects for indexed drawing
    - Uniform Buffer Objects for shader constants
    - Shader Storage Buffers for large data arrays
  
  ‚ñ° Phase 5: Shader-Based Rendering (Required for Core Profile)
    - Core profile removes fixed-function pipeline
    - Write vertex + fragment shaders for everything
    - Basic shaders: MVP transform, texture, lighting
    - Advanced: PBR materials, normal mapping
    - Compute shaders for particles, physics, culling
    - Shader management: compile, link, cache
  
  ‚ñ° Phase 6: Advanced OpenGL 4.6 Features
    - Direct State Access (DSA) for cleaner code
    - Shader pipeline objects for performance
    - Multi-draw indirect for massive batching
    - Bindless textures (ARB_bindless_texture)
    - SPIR-V shaders (cross-platform with Vulkan)
    - Buffer storage for persistent mapping
    - Compute shaders for GPU-driven rendering
  
  FALLBACK STRATEGY:
  ‚ñ° Try versions in order until one works:
    1. OpenGL 4.6 Core (preferred)
    2. OpenGL 4.5 Core (fallback 1)
    3. OpenGL 4.3 Core (fallback 2 - compute shaders minimum)
    4. OpenGL 3.3 Core (fallback 3 - basic modern OpenGL)
    5. OpenGL 2.1 Compatibility (last resort - current code works)
  
  ‚ñ° Maintain compatibility renderer for old hardware
    - Detect OpenGL version at runtime
    - Load appropriate rendering backend
    - Modern renderer for 4.6+
    - Legacy renderer for 2.1-3.2
    - Feature flags for optional capabilities
  
  ESTIMATED EFFORT:
  - Phase 1 (Quick Fix): 30 minutes - 1 hour
  - Phase 2 (GLAD): 1-2 hours
  - Phase 3 (Remove Legacy): 6-10 hours
  - Phase 4 (Modern Pipeline): 15-25 hours
  - Phase 5 (Shaders): 20-40 hours
  - Phase 6 (Advanced Features): 30-50+ hours
  **Total: 70-130 hours (2-3 weeks full-time)**
  
  IMMEDIATE ACTION (Try First):
  - Change OpenGL version request from 2.1 to 4.6
  - Add GLAD for function loading
  - Test if GLFW initialization succeeds
  - If it works, modern GPU may simply not support legacy 2.1!

‚ñ° Fix GLFW context creation for modern OpenGL (DO THIS FIRST!)
  - Current glfwWindowHint requests ancient OpenGL 2.1
  - Update to request latest OpenGL 4.6 core profile
  - **May immediately fix the GLFW initialization crash!**
  - See code example in Phase 1 above
  - Add fallback version chain if 4.6 fails
  - Test on current system - could solve the problem

‚ñ° Add GLAD or GLEW for extension loading
  - GLAD: Modern, generated loader (recommended)
  - GLEW: Older but stable, well-documented
  - Required for OpenGL 3.2+ on Windows
  - Handles function pointer loading
  - Provides extension checking

‚ñ° Investigate GLFW alternatives
  - Try SDL2 for window/input (different from SDL_mixer issue)
  - Test GLUT (legacy but stable, OpenGL 2.1 only)
  - Try native Windows CreateWindow + OpenGL
  - Consider Vulkan as long-term replacement

‚ñ° Software rendering fallback
  - Implement CPU-based 2D renderer
  - Use for debugging when GPU unavailable
  - Could be faster than no graphics at all
  - Good for remote/headless servers

‚ñ° Add comprehensive graphics capability detection
  - Query OpenGL version before initialization
  - Check for required extensions (ARB_*, EXT_*)
  - Detect GPU vendor and model (NVIDIA, AMD, Intel)
  - Log all graphics information on startup
  - Save to graphics_info.log for debugging
  - Detect DirectX version (for Windows diagnostics)

‚ñ° Shader system improvements
  - Complete shader loading/compilation from files
  - Add shader hot-reloading for development
  - Implement robust shader error reporting
  - Create shader preprocessor for variants (#ifdef support)
  - Add shader include system for shared code
  - Implement shader caching for faster loading

*** LEGACY ENGINE IMPROVEMENTS ***
==================================

IMMEDIATE TASKS (Next 1-2 weeks):
----------------------------------
‚ñ° Test distance-based camera hiding thoroughly
  - Verify camera visual appears/disappears correctly at 3-unit threshold
  - Test with different camera angles and player positions
  - Ensure smooth transitions without visual glitches

‚ñ° Player system roadmap
  - Review subsystem plan in `todo_player.txt`
  - Prioritize movement/input upgrades before adding advanced abilities
  - Sequence progression, multiplayer sync, and tooling support after core controls
  - Coordinate changes with camera and simulation teams

‚ñ° Performance profiling and optimization
  - Run performance benchmarks at different resolutions
  - Profile CPU/GPU usage during gameplay
  - Identify and optimize any remaining bottlenecks
  - Consider implementing frame rate limiter for consistent performance

‚ñ° Input system improvements
  - Add configurable key bindings
  - Implement mouse sensitivity settings
  - Add controller/gamepad support
  - Consider adding input recording/playback for testing

SHORT-TERM GOALS (Next 1-2 months):
-----------------------------------
‚ñ° Enhanced graphics features
  - Implement basic lighting system
  - Add texture support for entities
  - Implement fog/distance effects
  - Add particle effects system

‚ñ° Audio system implementation
  ‚úì Integrate audio library (SDL_mixer with SDL2) (COMPLETED)
    - Core AudioSystem class: 440 lines, full SDL_mixer integration
    - 3D audio: Distance attenuation + stereo panning
    - Volume hierarchy: Master, SFX, Music (0.0-1.0)
    - Resource management: Caching with lazy loading
    - Multi-channel: 32 simultaneous sounds
    - Music streaming: Background music with fade in/out
    - AudioFeedbackSystem: Connected to real audio playback
    - Build: Compiles successfully with auto-detection
    - Docs: docs/audio_system_design.md, docs/audio_system_implementation.md
  - Add sound effects for player actions (NEXT: need audio asset files)
  - Implement background music support (API ready, need music files)
  - Add volume controls and audio settings (need settings menu UI)

‚ñ° Game mechanics expansion
  - Implement collision detection system
  - Add physics simulation (gravity, momentum)
  - Create basic enemy AI
  - Add scoring/health system

‚ñ° User interface improvements
  ‚úì Create main menu system (COMPLETED - see docs/menu_system_summary.md)
    - MenuSystem framework: Generic reusable menu system
    - MainMenu implementation: New Game, Continue, Settings, Quit
    - Viewport3D rendering: OpenGL-based menu overlay
    - Next: Integrate into MainLoop with game state management
  - Add pause menu functionality
  - Implement settings/configuration screen
  - Add on-screen tutorials/help system

MEDIUM-TERM FEATURES (3-6 months):
---------------------------------
‚ñ° Multiplayer/networking support
  - Implement basic client-server architecture
  - Add player synchronization
  - Create lobby/join game system
  - Add network security measures

‚ñ° Level/world system
  - Implement level loading/saving
  - Add procedural world generation
  - Create terrain system
  - Add checkpoints/save system

‚ñ° Advanced graphics
  - Implement shader system
  - Add post-processing effects (bloom, motion blur)
  - Create skybox/environment mapping
  - Add dynamic shadows

‚ñ° Modding support
  - Create plugin/scripting system
  - Add asset hot-reloading
  - Implement custom entity creation tools
  - Create level editor

LONG-TERM VISION (6+ months):
-----------------------------
‚ñ° Cross-platform support
  - Port to Linux/macOS
 
‚è≥ Advanced engine features [ECS V2 IN PROGRESS - 95% Complete]
  ‚úÖ ECS (Entity Component System) V2 - Archetype-based system
     - ‚úÖ EntityHandle with versioning (src/ecs/EntityHandle.h - 100 lines)
     - ‚úÖ Archetype storage with SoA layout (src/ecs/Archetype.h - 350 lines)
     - ‚úÖ ArchetypeManager with transitions (src/ecs/ArchetypeManager.h/cpp - 210 lines)
     - ‚úÖ SystemSchedulerV2 with parallel execution (src/ecs/SystemSchedulerV2.h - 450 lines)
     - üîß EntityManagerV2 (95% - debugging component array sync)
     - ‚úÖ Test suite created (tests/test_ecs_v2.cpp - 320 lines)
     - ‚úÖ Comprehensive documentation (docs/ecs_v2_implementation_progress.md)
     
     STATUS: One bug remaining - component copying during archetype transitions
     IMPACT: 10-50x faster iteration, 70% less memory, 4-8x speedup on multi-core
     NEXT: Fix component array synchronization (30-60 min estimated)
     See: docs/ecs_v2_implementation_progress.md for details and todo_ecs.txt

     FOLLOW-UP MIGRATION TASKS:
     ‚ñ° Ship a compatibility facade that forwards legacy `EntityManager` calls into `EntityManagerV2` where supported.
       - Adapter header + documentation for unsupported pathways
     ‚ñ° Add a conversion pass that moves legacy-managed entities into archetype storage during load sequences.
       - Validate with migration regression tests
     ‚ñ° Update Simulation bootstrap to register systems via `SystemSchedulerV2` with feature flag toggle.
       - Maintain parity with current manual order while stabilizing rollout

  ‚ñ° Add physics engine integration (Bullet, PhysX)
  ‚ñ° Create animation system
  ‚ñ° Add AI pathfinding system

‚ñ° Tool development
  - Create integrated development environment
  - Build asset pipeline tools
  - Develop debugging/profiling tools
  - Add automated testing framework

‚ñ° Community and distribution
  - Create documentation and tutorials
  - Set up continuous integration/deployment
  - Build community around the engine
  - Consider commercial licensing options

CODE QUALITY & MAINTENANCE:
---------------------------
‚úÖ Create comprehensive TODO document [COMPLETED 2025-10-10]
  ‚úÖ docs/todo/TODO_IMPROVEMENTS.md with categorized tasks
  ‚úÖ Prioritized by High/Medium/Low
  ‚úÖ Documented all fixes and improvements from today
  ‚úÖ Added environment variable usage guide

‚ñ° Fix compiler warnings
  - Unused parameter warnings in Viewport3D::Render (playerX, playerY, playerZ)
  - Unused parameter warnings in Viewport3D::DrawEntity
  - Integer overflow warning in MainLoop (GLFW_KEY_UP conversion to char)
  - Unused variable 'turnSpeed' in MainLoop
  - Add [[maybe_unused]] or (void)param to suppress
  - Consider enabling -Werror to make warnings errors

‚ñ° Code cleanup and refactoring
  - Viewport3D.cpp is 2295 lines - split into multiple files
  - Remove commented-out code (XInput sections, SDL fallback)
  - Remove unused includes and forward declarations
  - Separate rendering backends (GLFW, SDL, headless)
  - Extract rendering systems into separate classes

‚ñ° Add debug/release build configurations
  - Debug: -g -O0 with assertions enabled
  - Release: -O3 with optimizations, assertions disabled
  - Profile: -O2 -g for profiling with symbols
  - Add configuration selector to Makefile

‚ñ° Improve error handling
  - Add exception handling where appropriate
  - Use RAII for resource management
  - Add proper cleanup in destructors
  - Handle all malloc/new failures gracefully

‚ñ° Memory leak detection
  - Run with Valgrind (on Linux) or Dr. Memory (Windows)
  - Add smart pointer usage where appropriate
  - Audit all new/delete pairs
  - Consider adding memory allocation tracking

TESTING & QUALITY ASSURANCE:
----------------------------
‚ñ° Create automated test suite
  - Use headless mode for running tests
  - Test all game systems independently
  - Add CI/CD pipeline (GitHub Actions)
  - Run tests on every commit

‚ñ° Add unit tests for each system
  - Camera system tests (movement, rotation, zoom)
  - Input system tests (key mapping, mouse tracking)
  - ECS tests (entity creation, component manipulation)
  - Physics tests (collision, forces, integration)
  - Rendering tests (coordinate transforms, culling)

‚ñ° Integration testing
  - Test camera + player interaction
  - Test input + movement + physics pipeline
  - Test rendering + ECS iteration
  - Test resource loading + rendering
  - Test audio + game events

‚ñ° Performance testing and benchmarking
  - Profile frame times in different scenarios
  - Measure entity iteration performance
  - Test with increasing entity counts (100, 1000, 10000)
  - Benchmark rendering with complex scenes
  - Profile memory usage over time

‚ñ° Stress testing
  - Run for extended periods (hours)
  - Test with maximum entity count
  - Simulate rapid state changes
  - Test edge cases and boundary conditions
  - Monitor for memory leaks over time

‚ñ° Crash reporting and debugging
  - Add stack trace on crash (Windows SEH)
  - Log last N frames of input before crash
  - Dump entity state on crash
  - Add crash minidump generation
  - Create automated crash analysis

DOCUMENTATION IMPROVEMENTS:
---------------------------
‚ñ° Create setup guide for Windows
  - Complete installation steps
  - MSYS2 setup instructions
  - Required packages and versions
  - Common issues and solutions
  - Screenshots and examples

‚ñ° Document headless mode usage
  - Environment variables reference
  - Use cases for testing
  - Example automated test scripts
  - Performance comparison vs graphics mode
  - Limitations and caveats

‚ñ° Architecture documentation
  - System overview diagrams
  - Component interaction flowcharts
  - Data flow diagrams
  - Thread/concurrency model
  - Memory layout diagrams

‚ñ° API documentation
  - Doxygen comments for all public APIs
  - Usage examples for each system
  - Design rationale and decisions
  - Performance characteristics
  - Thread safety guarantees

‚ñ° Developer onboarding guide
  - How to build and run
  - Code organization explanation
  - Coding standards and conventions
  - How to add new systems
  - Debugging tips and tricks

‚ñ° User manual (when applicable)
  - Controls and input reference
  - Game mechanics explanation
  - Settings and configuration
  - Troubleshooting guide
  - FAQ section

BUILD SYSTEM ENHANCEMENTS:
-------------------------
‚ñ° Improve Makefile robustness
  - Auto-detect Windows vs Unix
  - Use proper path separators
  - Handle spaces in paths
  - Add verbose mode for debugging
  - Add quiet mode for clean output

‚ñ° Add build configurations
  - make debug (with symbols, no optimization)
  - make release (optimized, no debug)
  - make profile (optimized with symbols)
  - make sanitize (with AddressSanitizer/UBSan)

‚ñ° Parallel build support
  - Enable -j flag for make
  - Ensure proper dependency tracking
  - Test with different core counts
  - Measure build time improvements

‚ñ° Precompiled headers
  - Create PCH for stable headers (STL, OpenGL)
  - Measure compilation time improvement
  - Ensure all source files use PCH
  - Update on header changes

‚ñ° Dependency tracking
  - Auto-generate header dependencies
  - Rebuild when headers change
  - Track library dependencies
  - Detect missing dependencies early

PLATFORM COMPATIBILITY:
----------------------
‚ñ° Test on different Windows versions
  - Windows 10 (various builds)
  - Windows 11
  - Windows Server editions
  - Document minimum required version

‚ñ° Test with different compilers
  - MinGW GCC (current)
  - MSVC (Visual Studio)
  - Clang for Windows
  - Document compiler requirements

‚ñ° Prepare for Linux port
  - Use cross-platform APIs
  - Avoid Windows-specific code
  - Test with Wine on Linux
  - Plan Linux build system

‚ñ° Prepare for macOS port
  - Use OpenGL instead of DirectX
  - Avoid Windows-specific APIs
  - Plan for Metal support later
  - Test with GLFW on macOS

CODE QUALITY & MAINTENANCE:
---------------------------
‚ñ° Code cleanup and refactoring
  - Remove unused code and dependencies
  - Improve error handling and logging
  - Add comprehensive unit tests
  - Implement code formatting standards

‚ñ° Documentation
  - Create API documentation
  - Write developer guides
  - Add inline code comments
  - Create video tutorials

‚ñ° Bug tracking and fixes
  - Set up issue tracking system
  - Implement crash reporting
  - Regular bug fix releases
  - User feedback integration

TECHNICAL DEBT & OPTIMIZATION:
-------------------------------
‚ñ° Memory management improvements
  - Implement object pooling
  - Add memory leak detection
  - Optimize memory allocation patterns
  - Implement garbage collection for scripts

‚ñ° Build system enhancements
  - Improve Makefile for different configurations
  - Add support for different compilers
  - Implement automated dependency management
  - Create installer/package system

‚ñ° Security and stability
  - Add input validation and sanitization
  - Implement proper error recovery
  - Add security audits
  - Create backup/recovery systems

RESEARCH & EXPERIMENTATION:
---------------------------
‚ñ° Emerging technologies integration
  - Explore VR/AR support
  - Investigate machine learning integration
  - Research cloud gaming possibilities
  - Look into /gaming integration

‚ñ° Performance research
  - Study advanced rendering techniques
  - Research new physics simulation methods
  - Explore AI advancements for game development
  - Investigate new input methods (gesture, voice, etc.)

OPTIMIZATION & PERFORMANCE (Advanced):
--------------------------------------
‚ñ° Profile and optimize hot paths
  - Identify bottlenecks with profiler (gprof, Visual Studio Profiler)
  - Focus on frame update loop and entity iteration
  - Optimize rendering pipeline (frustum culling, batching)
  - Use profiler-guided optimization (PGO)

‚ñ° Memory optimization strategies
  - Object pooling for frequently created/destroyed objects
  - SoA (Structure of Arrays) for cache-friendly entity data
  - Reduce memory fragmentation with custom allocators
  - Monitor and minimize peak memory usage

‚ñ° Multithreading and parallelism
  - Separate render thread from game logic thread
  - Parallelize entity system updates (ECS V2 ready)
  - Async resource loading on background threads
  - Job system for task parallelism
  - Lock-free data structures for performance

‚ñ° GPU compute integration
  - Offload calculations to compute shaders
  - GPU particle systems (millions of particles)
  - GPU-based simple physics
  - Investigate CUDA/OpenCL for heavy computation

ADVANCED FEATURES & SYSTEMS:
----------------------------
‚ñ° AI Systems
  - State machines and behavior trees for NPCs
  - NavMesh generation and A* pathfinding
  - Combat AI with tactics and positioning
  - Machine learning integration for adaptive AI

‚ñ° Procedural Generation
  - Terrain generation (heightmaps, biomes)
  - Procedural missions and quests
  - Random encounters and events
  - Mesh and texture variation

‚ñ° Networking & Multiplayer
  - Client-server architecture
  - Entity synchronization with delta compression
  - Client prediction and lag compensation
  - Matchmaking and lobby system

‚ñ° VR/AR Support (Future)
  - OpenVR/SteamVR integration
  - Room-scale tracking
  - Foveated rendering
  - VR-optimized UI and interactions

‚ñ° Modding & Extensibility
  - Lua or Python scripting system
  - Hot-reloading for scripts and assets
  - Custom entity/component creation
  - Mod packaging and distribution (Steam Workshop)

‚ñ° Analytics & Telemetry
  - Gameplay analytics and behavior tracking
  - Performance metrics and crash reporting
  - Development metrics (build times, code complexity)
  - A/B testing framework

REFERENCE DOCUMENTS:
-------------------
See docs/todo/TODO_IMPROVEMENTS.md for detailed 2025-10-10 fixes and improvements
See docs/ folder for comprehensive system documentation
See todo_*.txt files for system-specific task breakdowns

This roadmap provides a comprehensive plan for evolving Nova-Engine from a basic 3D engine into a full-featured game development platform. Priorities should be adjusted based on user feedback, performance requirements, and development resources available.

COMPLETION TRACKING (2025-10-10):
---------------------------------
Major accomplishments today:
- ‚úÖ SDL dependencies completely removed
- ‚úÖ Headless mode fully functional for testing
- ‚úÖ Camera direction corrected (facing player)
- ‚úÖ Frame limiter implemented
- ‚úÖ Comprehensive documentation created
- ‚ö†Ô∏è GLFW and XInput crashes identified (needs investigation)
- ‚ö†Ô∏è Build system needs Windows compatibility improvements

Next priorities:
1. Fix GLFW initialization crash (high priority - blocks graphics)
2. Implement automated testing using headless mode
3. Complete ECS V2 final bug fix (component array sync)
4. Add DLL checker/copier script
5. Fix compiler warnings

This roadmap provides a comprehensive plan for evolving Nova-Engine from a basic 3D engine into a full-featured game development platform. Priorities should be adjusted based on user feedback, performance requirements, and development resources available.